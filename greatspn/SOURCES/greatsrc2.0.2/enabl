afire.c:	set_t_fire_name(cur_trans->tag);
animation.c:    c_p->x = trans->center.x;
animation.c:    c_p->y = trans->center.y;
animation.c:		 cur_trans = cur_trans->next, ++count) {
animation.c:	    if (IsLayerListVisible(cur_trans->layer)) {
animation.c:		     cur_trans = cur_trans->next, ++count) {
animation.c:		    if (IsLayerListVisible(cur_trans->layer )) {
arc.c:			ChopTrans(&start_x, &start_y, cur_x, cur_y, cur_arc->trans->orient);
arc.c:		p3x = near->trans->center.x;
arc.c:		p3y = near->trans->center.y;
arc.c:		ChopTrans(&p3x, &p3y, p2x, p2y, near->trans->orient);
arc.c:				cur_x = near->trans->center.x;
arc.c:				cur_y = near->trans->center.y;
arc.c:					   cur_x, cur_y, cur_arc->trans->orient);
arc.c:							   point->x, point->y, cur_arc->trans->orient);
arc.c:			cur_x = near->trans->center.x;
arc.c:			cur_y = near->trans->center.y;
arcdialog.c:	sprintf(buf,"Transition : %s",dialog_arc->trans->tag);
cc.c:    c_p->x = trans->center.x;
cc.c:    c_p->y = trans->center.y;
cc.c:	StatusPrintf( "transition %s is not causally connected",cur_trans->tag);
chop.c:    switch (trans->orient) 
chop.c:    switch (trans->orient) 
color.c:	if (trans->color == NULL && trans->lisp == NULL)
color.c:	xloc = (trans->center.x + trans->colpos.x - x_off) * zoom_level;
color.c:	yloc = (trans->center.y + trans->colpos.y - y_off) * zoom_level;
color.c:	if (trans->color != NULL)
color.c:		gdiDrawText(ds, (int) (xloc), (int) (yloc),op, canvas_font, trans->color);
color.c:		gdiDrawText(ds, (int) (xloc), (int) (yloc),op, canvas_font, trans->lisp->tag);
color.c:	 last_trans = last_trans->next)
color.c: 		if (last_trans->lisp == near->lisps) 
color.c:			last_trans->lisp = NULL;
color.c:	 last_trans = last_trans->next)
color.c:			if (last_trans->lisp == near->lisps) 
color.c:				last_trans->lisp = NULL;
color.c:			if (near->trans->color == NULL && near->trans->lisp == NULL)
color.c:			if (near->trans->color != NULL)
color.c:				gdiDrawText(&mainDS,(int) (fix_x), (int) (fix_y),XOR, canvas_font, near->trans->color);
color.c:				gdiDrawText(&mainDS,(int) (fix_x), (int) (fix_y),XOR, canvas_font, near->trans->lisp->tag);
color.c:			if (near->trans->color != NULL)
color.c:				gdiDrawText(&mainDS,(int) (fix_x), (int) (fix_y),XOR, canvas_font, near->trans->color);
color.c:				gdiDrawText(&mainDS,(int) (fix_x), (int) (fix_y),XOR, canvas_font, near->trans->lisp->tag);
color.c:			sss = ((near->trans->color != NULL) ?
color.c:				   (near->trans->color) :
color.c:				   (near->trans->lisp->tag));
color.c:			near->trans->colpos.x = xloc - near->trans->center.x;
color.c:			near->trans->colpos.y = yloc - near->trans->center.y;
color.c:			if (near->trans->color == NULL && near->trans->lisp == NULL)
color.c:			fix_x = (near->trans->center.x + near->trans->colpos.x) * zoom_level;
color.c:			fix_y = (near->trans->center.y + near->trans->colpos.y) * zoom_level;
colordialog.c:		 last_trans = last_trans->next)
colordialog.c:			if(last_trans->color != NULL)
colordialog.c:				if(!strcmp(last_trans->color,oldtag))
colordialog.c:					free(last_trans->color);
colordialog.c:					last_trans->color=strdup(tag);
colordialog.c:		 last_trans = last_trans->next)
colordialog.c:				if(last_trans->color != NULL)
colordialog.c:					if(!strcmp(last_trans->color,oldtag))
colordialog.c:						free(last_trans->color);
colordialog.c:						last_trans->color=strdup(tag);
drag.c:			arc->point->x = arc->trans->center.x;
drag.c:			arc->point->y = arc->trans->center.y;
drag.c:				   arc->trans->orient);
drag.c:	for (trans = selected.trans; trans != NULL; trans = trans->next) {
drag.c:	temp_tr->orient = trans->orient;
drag.c:	if ((ii = temp_tr->enabl = trans->enabl) >= 0)
drag.c:		temp_tr->fire_rate.ff = trans->fire_rate.ff;
drag.c:		temp_tr->fire_rate.fp[ii] = trans->fire_rate.fp[ii];
drag.c:	temp_tr->kind = trans->kind;
drag.c:	temp_tr->rpar = trans->rpar;
drag.c:	if (trans->mark_dep == NULL)
drag.c:	   /*		for (m_d = trans->mark_dep, temp_co = NULL;
drag.c:	   temp_tr->mark_dep = (char *) emalloc(strlen(trans->mark_dep)+1);
drag.c:	   strcpy(temp_tr->mark_dep,trans->mark_dep);
drag.c:	temp_tr->center.x = trans->center.x + delta_x;
drag.c:	temp_tr->center.y = trans->center.y + delta_y;
drag.c:	temp_tr->tagpos.x = trans->tagpos.x;
drag.c:	temp_tr->tagpos.y = trans->tagpos.y;
drag.c:	if (trans->color != NULL) {
drag.c:		temp_tr->color = emalloc((unsigned) (strlen(trans->color) + 1));
drag.c:		strcpy(temp_tr->color, trans->color);
drag.c:		temp_tr->colpos.x = trans->colpos.x;
drag.c:		temp_tr->colpos.y = trans->colpos.y;
drag.c:	else if (trans->lisp != NULL) {
drag.c:		temp_tr->lisp = trans->lisp;
drag.c:		temp_tr->colpos.x = trans->colpos.x;
drag.c:		temp_tr->colpos.y = trans->colpos.y;
drag.c:	temp_tr->ratepos.x = trans->ratepos.x;
drag.c:	temp_tr->ratepos.y = trans->ratepos.y;
drag.c:	for (trans = group->trans; trans != NULL; trans = trans->next) {
drag.c:		temp_tr->orient = trans->orient;
drag.c:		temp_tr->enabl = trans->enabl;
drag.c:		temp_tr->kind = trans->kind;
drag.c:		temp_tr->fire_rate.ff = trans->fire_rate.ff;
drag.c:		temp_tr->rpar = trans->rpar;
drag.c:		if (trans->mark_dep == NULL)
drag.c:		for (m_d = trans->mark_dep, temp_co = NULL;
drag.c:		 temp_tr->mark_dep = (char *) emalloc(strlen(trans->mark_dep)+1);
drag.c:	   	 strcpy(temp_tr->mark_dep,trans->mark_dep);
drag.c:		temp_tr->center.x = trans->center.x + delta_x;
drag.c:		temp_tr->center.y = trans->center.y + delta_y;
drag.c:		temp_tr->tagpos.x = trans->tagpos.x;
drag.c:		temp_tr->tagpos.y = trans->tagpos.y;
drag.c:		if (trans->color != NULL) {
drag.c:		temp_tr->color = emalloc((unsigned) (strlen(trans->color) + 1));
drag.c:		strcpy(temp_tr->color, trans->color);
drag.c:		temp_tr->colpos.x = trans->colpos.x;
drag.c:		temp_tr->colpos.y = trans->colpos.y;
drag.c:		else if (trans->lisp != NULL) {
drag.c:		temp_tr->lisp = trans->lisp;
drag.c:		temp_tr->colpos.x = trans->colpos.x;
drag.c:		temp_tr->colpos.y = trans->colpos.y;
drag.c:		temp_tr->ratepos.x = trans->ratepos.x;
drag.c:		temp_tr->ratepos.y = trans->ratepos.y;
drag.c:		arc->point->x = arc->trans->center.x;
drag.c:		arc->point->y = arc->trans->center.y;
drag.c:			   arc->trans->orient);
drag.c:		trans->center.x += fix_x;
drag.c:		trans->center.y += fix_y;
drag.c:		trans = trans->next;
drag.c:	for (trans = group->trans; trans != NULL; trans = trans->next) {
drag.c:		trans->center.x += fix_x;
drag.c:		trans->center.y += fix_y;
drag.c:		arc->point->x = arc->trans->center.x;
drag.c:		arc->point->y = arc->trans->center.y;
drag.c:			   arc->trans->orient);
draw.c:	int     xd = (int) (((trans->center.x - x_off) * zoom_level) - ((float)pixdim)/2);
draw.c:	int     yd = (int) (((trans->center.y - y_off) * zoom_level) - ((float)pixdim)/2);
draw.c:		switch (trans->orient)
draw.c:		switch(trans->kind)
draw.c:				PSTransition((trans->center.x - x_off) * zoom_level,(trans->center.y - y_off) * zoom_level,trans_length,titrans_height,angle,0);
draw.c:				PSTransition((trans->center.x - x_off) * zoom_level,(trans->center.y - y_off) * zoom_level,trans_length,titrans_height,angle,1);
draw.c:				PSTransition((trans->center.x - x_off) * zoom_level,(trans->center.y - y_off) * zoom_level,trans_length,imtrans_height,angle,1);   
draw.c:	if (trans->kind != DETERMINISTIC) 
draw.c:	    if (trans->kind > 1) 
draw.c:			float           xx = (trans->center.x + trans->tagpos.x - x_off) * zoom_level;
draw.c:			float           yy = (trans->center.y + trans->tagpos.y - y_off) * zoom_level;
draw.c:			ShowTransPri(xx, yy, trans->kind, ds,op);
draw.c:   if (!IsLayerListVisible(trans->layer))
draw.c:			sprintf(string, "%s", arc->trans->tag);
draw.c:			sprintf(string, "%1d*%s", -(arc->mult), arc->trans->tag);
draw.c:   for (last_trans = net->trans; last_trans != NULL; last_trans = last_trans->next)
draw.c:      for (last_trans = last_group->trans; last_trans != NULL; last_trans = last_trans->next)
draw.c:   for (last_trans = net->trans; last_trans != NULL; last_trans = last_trans->next)
draw.c:      for (last_trans = last_group->trans; last_trans != NULL; last_trans = last_trans->next)
ecs.c:    c_p->x = trans->center.x;
ecs.c:    c_p->y = trans->center.y;
ecs.c:    sprintf(string,"transition %s is not contained in any E-conflit sets", cur_trans->tag);
fire.c:	if (!IsLayerListVisible(trans->layer))
fire.c:	c_p->x = trans->center.x;
fire.c:	c_p->y = trans->center.y;
fire.c:	for (trans = netobj->trans; trans != NULL; trans = trans->next)
fire.c:	if (trans->enabled) {
fire.c:		trans->enabled = FALSE;
fire.c:		for (trans = group->trans; trans != NULL; trans = trans->next)
fire.c:		if (trans->enabled) {
fire.c:			trans->enabled = FALSE;
fire.c:	if (!cur_trans->enabled)
fire.c:	set_t_fire_name(cur_trans->tag);
fire.c:	for (trans = gp->trans; trans != NULL; trans = trans->next)
fire.c:	    trans->enabled = FALSE;
fire.c:	for (trans = gp->trans; trans != NULL; trans = trans->next)
fire.c:	    if (trans->enabled) {
fire.c:    for (trans = netobj->trans; trans != NULL; trans = trans->next)
fire.c:	trans->enabled = TRUE;
fire.c:	for (trans = group->trans; trans != NULL; trans = trans->next)
fire.c:	    trans->enabled = TRUE;
fire.c:		arc->trans->enabled = FALSE;
fire.c:		arc->trans->enabled = FALSE;
fire.c:	for (trans = netobj->trans; trans != NULL; trans = trans->next)
fire.c:	    trans->enabled = FALSE;
fire.c:	for (trans = netobj->trans; trans != NULL; trans = trans->next)
fire.c:	    if (trans->enabled) {
fire.c:	for (trans = gp->trans; trans != NULL; trans = trans->next) {
fire.c:	    trans->enabled = TRUE;
fire.c:	    if (trans->kind == cur_pri)
fire.c:			arc->trans->enabled = FALSE;
fire.c:			arc->trans->enabled = FALSE;
fire.c:	for (trans = gp->trans; trans != NULL; trans = trans->next) {
fire.c:	    if (trans->enabled) {
fire.c:		trans->enabled = FALSE;
fire.c:    trans->enabled = TRUE;
fire.c:	    trans->enabled = FALSE;
fire.c:    if (trans->enabled) {
fire.c:			trans->enabled = FALSE;
fire.c:			trans->enabled = FALSE;
fire.c:	if (trans->enabled) {
fire.c:		trans->enabled = (!some_enabled);
fire.c:	    if (trans->enabled) {
fire.c:    for (trans = netobj->trans; trans != NULL; trans = trans->next) {
fire.c:	for (trans = group->trans; trans != NULL; trans = trans->next)
layer.c:	 trans->layer = LayerRealloc(trans->layer);
layer.c:	 trans = trans->next;
layer.c:      for (trans = group->trans; trans != NULL; trans = trans->next)
layer.c:	 trans->layer = LayerRealloc(trans->layer);
layer.c:				  DeleteLayerFromLayerList(ln, trans->layer);
layer.c:				  trans = trans->next;
layer.c:			  for (trans = group->trans; trans != NULL; trans = trans->next)
layer.c:				  DeleteLayerFromLayerList(ln, trans->layer);
layer.c:	 ResetVisibleLayers(trans->layer);
layer.c:	 trans = trans->next;
layer.c:	   trans->next)
layer.c:	 ResetVisibleLayers(trans->layer);
layer.c:				AddVisibleLayers2LayerList(trans->layer );
layer.c:				trans = trans->next;
layer.c:			for (trans = group->trans; trans != NULL; trans = trans->next)
layer.c:				AddVisibleLayers2LayerList(trans->layer );
line.c:	       cur_arc->trans->orient);
line.c:	       cur_arc->trans->orient);
line.c:    cur_arc->point->x = cur_arc->trans->center.x;
line.c:    cur_arc->point->y = cur_arc->trans->center.y;
line.c:		fix_x = p1->x = cur_arc->trans->center.x;
line.c:		fix_y = p1->y = cur_arc->trans->center.y;
liveness.c:    for (trans = netobj->trans; trans != NULL; trans = trans->next) {
liveness.c:	xloc = (trans->center.x + trans->ratepos.x) * zoom_level;
liveness.c:	yloc = (trans->center.y + trans->ratepos.y + 10) * zoom_level;
liveness.c:		    trans->Lbound, trans->Rbound, trans->Ebound);
liveness.c:	    sprintf(linebuf, "L=%d", trans->Lbound);
liveness.c:	for (trans = group->trans; trans != NULL; trans = trans->next) {
liveness.c:		xloc = (trans->center.x + trans->ratepos.x) * zoom_level;
liveness.c:		yloc = (trans->center.y + trans->ratepos.y + 10) * zoom_level;
liveness.c:			trans->Lbound, trans->Rbound, trans->Ebound);
liveness.c:		sprintf(linebuf, "L=%d", trans->Lbound);
liveness.c:	for (trans = netobj->trans; trans != NULL; trans = trans->next) {
liveness.c:	xloc = (trans->center.x + trans->ratepos.x) * zoom_level;
liveness.c:	yloc = (trans->center.y + trans->ratepos.y + 10) * zoom_level;
liveness.c:			trans->Lbound, trans->Rbound, trans->Ebound);
liveness.c:		sprintf(linebuf, "L=%d", trans->Lbound);
liveness.c:	for (trans = group->trans; trans != NULL; trans = trans->next) {
liveness.c:		xloc = (trans->center.x + trans->ratepos.x) * zoom_level;
liveness.c:		yloc = (trans->center.y + trans->ratepos.y + 10) * zoom_level;
liveness.c:			trans->Lbound, trans->Rbound, trans->Ebound);
liveness.c:		sprintf(linebuf, "L=%d", trans->Lbound);
liveness.c:		 trans = trans->next) {
liveness.c:		if (min_liv == -1 || min_liv > trans->Lbound)
liveness.c:		min_liv = trans->Lbound;
liveness.c:		for (trans = group->trans; trans != NULL; trans = trans->next) {
liveness.c:		if (min_liv == -1 || min_liv > trans->Lbound)
liveness.c:			min_liv = trans->Lbound;
liveness.c:	 trans = trans->next) {
liveness.c:	trans->Ebound = ii;
liveness.c:		trans->Rbound = maxj;
liveness.c:	trans->Lbound = ii;
liveness.c:	for (trans = group->trans; trans != NULL; trans = trans->next) {
liveness.c:		trans->Ebound = ii;
liveness.c:		trans->Rbound = maxj;
liveness.c:		trans->Lbound = ii;
load.c:	trans->tag = (char *) emalloc(TAG_SIZE);
load.c:	trans->color = NULL;
load.c:	trans->lisp = NULL;
load.c:	getname(trans->tag);
load.c:	fprintf(stderr, "          %s enabl=%d\n", trans->tag, mark);
load.c:	trans->layer =NewLayerList(WHOLENET,NULL);
load.c:	trans->center.x = IN_TO_PIX(x);
load.c:	trans->center.y = IN_TO_PIX(y);
load.c:	    trans->tagpos.x = -(trans_length / 2 + 10);
load.c:	    trans->tagpos.y = -18;
load.c:	    trans->ratepos.x = trans_length / 2 + 3;
load.c:	    trans->ratepos.y = titrans_height;
load.c:	    trans->tagpos.x = IN_TO_PIX(tagx) - trans->center.x;
load.c:	    trans->tagpos.y = IN_TO_PIX(tagy) - trans->center.y;
load.c:		trans->ratepos.x = trans_length / 2 + 3;
load.c:		trans->ratepos.y = titrans_height;
load.c:		trans->ratepos.x = IN_TO_PIX(ratex) - trans->center.x;
load.c:		trans->ratepos.y = IN_TO_PIX(ratey) - trans->center.y;
load.c:		       SetLayer2LayerList(ln,trans->layer);
load.c:			trans->colpos.x = trans_length / 2 + 3;
load.c:			trans->colpos.y = -7;
load.c:			trans->colpos.x = IN_TO_PIX(x) - trans->center.x;
load.c:			trans->colpos.y = IN_TO_PIX(y) - trans->center.y;
load.c:			    trans->lisp = (struct lisp_object *) ii;
load.c:			    trans->color = (char *) emalloc(strlen(cp) + 1);
load.c:			    strcpy(trans->color, cp);
load.c:	    trans->fire_rate.ff = ftemp;
load.c:	    trans->rpar = NULL;
load.c:	    trans->mark_dep = NULL;
load.c:	    trans->fire_rate.ff = 1.0;
load.c:		trans->rpar = NULL;
load.c:		trans->mark_dep = NULL;
load.c:		  trans->mark_dep = (char *)emalloc(strlen(temp)+1);
load.c:		  strcpy(trans->mark_dep,temp);
load.c:		trans->rpar = rpar;
load.c:		trans->mark_dep = NULL;
load.c:		trans->fire_rate.ff = ftemp = rpar->value;
load.c:	    trans->fire_rate.fp = (float *) emalloc(j * sizeof(float));
load.c:	    trans->fire_rate.fp[0] = ftemp;
load.c:		trans->fire_rate.fp[-(mark + j)] = ftemp;
load.c:	trans->enabl = mark;
load.c:	trans->enabled = FALSE;
load.c:	trans->orient = orien;
load.c:		for (prev_trans = netobj->trans; prev_trans->next != NULL;
load.c:		     prev_trans = prev_trans->next);
load.c:		prev_trans->next = trans;
load.c:	    trans->kind = knd;
load.c:	    trans->next = NULL;
load.c:		for (prev_trans = group->trans; prev_trans->next != NULL;
load.c:		     prev_trans = prev_trans->next);
load.c:		prev_trans->next = trans;
load.c:	    trans->kind = group->pri;
load.c:	    trans->next = NULL;
load.c:		 last_trans = last_trans->next)
load.c:		if ((int) (last_trans->lisp) == nl) {
load.c:		    last_trans->lisp = lisp;
load.c:		     last_trans = last_trans->next)
load.c:		    if ((int) (last_trans->lisp) == nl) {
load.c:			last_trans->lisp = lisp;
load.c:	cph->x = trans->center.x;
load.c:	cph->y = trans->center.y;
load.c:		   cph->next->x, cph->next->y, trans->orient);
lpabso.c:	sprintf(string,"e_%s;\n", cur_trans->tag );
lpabso.c:	compute_show_lpp(cur_trans->tag);
lpbounds.c:	sprintf(string,"-x_%s;\n", cur_trans->tag );
lpbounds.c:	compute_show_lpp(cur_trans->tag);
lpbounds.c:	sprintf(string,"x_%s;\n", cur_trans->tag );
lpbounds.c:	compute_show_lpp(cur_trans->tag);
me.c:    c_p->x = trans->center.x;
me.c:    c_p->y = trans->center.y;
me.c:    sprintf(string, "transition %s is not contained in any mutual exclusion", cur_trans->tag);
mirror.c:		    arc->point->x = arc->trans->center.x;
mirror.c:		    arc->point->y = arc->trans->center.y;
mirror.c:			       arc->trans->orient);
mirror.c:    for (trans = selected.trans; trans != NULL; trans = trans->next) 
mirror.c:	temp_tr->kind = trans->kind;
mirror.c:	if ((ii = temp_tr->enabl = trans->enabl) >= 0)
mirror.c:	    temp_tr->fire_rate.ff = trans->fire_rate.ff;
mirror.c:		temp_tr->fire_rate.fp[ii] = trans->fire_rate.fp[ii];
mirror.c:	temp_tr->rpar = trans->rpar;
mirror.c:	if (trans->mark_dep == NULL)
mirror.c:	    for (m_d = trans->mark_dep, temp_co = NULL;
mirror.c:	   temp_tr->mark_dep = (char *) emalloc(strlen(trans->mark_dep)+1);
mirror.c:	   strcpy(temp_tr->mark_dep,trans->mark_dep);	
mirror.c:	    temp_tr->orient = rot_trans((int) (trans->orient),
mirror.c:	    temp_tr->center.x = m_center - trans->center.x;
mirror.c:	    temp_tr->center.y = trans->center.y;
mirror.c:	    temp_tr->orient = rot_trans((int) (trans->orient),
mirror.c:	    temp_tr->center.x = trans->center.x;
mirror.c:	    temp_tr->center.y = m_center - trans->center.y;
mirror.c:	temp_tr->tagpos.x = trans->tagpos.x;
mirror.c:	temp_tr->tagpos.y = trans->tagpos.y;
mirror.c:	if (trans->color != NULL)
mirror.c:	    temp_tr->color = emalloc((unsigned) (strlen(trans->color) + 1));
mirror.c:	    strcpy(temp_tr->color, trans->color);
mirror.c:	    temp_tr->colpos.x = trans->colpos.x;
mirror.c:	    temp_tr->colpos.y = trans->colpos.y;
mirror.c:	else if (trans->lisp != NULL) 
mirror.c:	    temp_tr->lisp = trans->lisp;
mirror.c:		temp_tr->colpos.x = trans->colpos.x;
mirror.c:	    temp_tr->colpos.y = trans->colpos.y;
mirror.c:	temp_tr->ratepos.x = trans->ratepos.x;
mirror.c:	temp_tr->ratepos.y = trans->ratepos.y;
mirror.c:	for (trans = group->trans; trans != NULL; trans = trans->next)
mirror.c:	    temp_tr->orient = trans->orient;
mirror.c:	    temp_tr->enabl = trans->enabl;
mirror.c:	    temp_tr->kind = trans->kind;
mirror.c:	    temp_tr->fire_rate.ff = trans->fire_rate.ff;
mirror.c:	    temp_tr->rpar = trans->rpar;
mirror.c:	    if (trans->mark_dep == NULL)
mirror.c:		for (m_d = trans->mark_dep, temp_co = NULL;
mirror.c:	      	temp_tr->mark_dep = (char *) emalloc(strlen(trans->mark_dep)+1);
mirror.c:	   	strcpy(temp_tr->mark_dep,trans->mark_dep);
mirror.c:		temp_tr->orient = rot_trans((int) (trans->orient),
mirror.c:		temp_tr->center.x = m_center - trans->center.x;
mirror.c:		temp_tr->center.y = trans->center.y;
mirror.c:		temp_tr->orient = rot_trans((int) (trans->orient),
mirror.c:		temp_tr->center.x = trans->center.x;
mirror.c:		temp_tr->center.y = m_center - trans->center.y;
mirror.c:	    temp_tr->tagpos.x = trans->tagpos.x;
mirror.c:	    temp_tr->tagpos.y = trans->tagpos.y;
mirror.c:	    if (trans->color != NULL) {
mirror.c:		temp_tr->color = emalloc((unsigned) (strlen(trans->color) + 1));
mirror.c:		strcpy(temp_tr->color, trans->color);
mirror.c:		temp_tr->colpos.x = trans->colpos.x;
mirror.c:		temp_tr->colpos.y = trans->colpos.y;
mirror.c:	    else if (trans->lisp != NULL) {
mirror.c:		temp_tr->lisp = trans->lisp;
mirror.c:		temp_tr->colpos.x = trans->colpos.x;
mirror.c:		temp_tr->colpos.y = trans->colpos.y;
mirror.c:		temp_tr->ratepos.x = trans->ratepos.x;
mirror.c:	    temp_tr->ratepos.y = trans->ratepos.y;
mirror.c:		arc->point->x = arc->trans->center.x;
mirror.c:		arc->point->y = arc->trans->center.y;
mirror.c:			   arc->trans->orient);
modify.c:    for (trans = selected.trans; trans != NULL; trans = trans->next)
modify.c:	for (trans = group->trans; trans != NULL; trans = trans->next)
modify.c:    trans->orient = rot_trans((int) (trans->orient), how);
modify.c:    transform_coord(how, trans->center.x, trans->center.y, &newx, &newy);
modify.c:    trans->center.x = newx;
modify.c:    trans->center.y = newy;
move.c:	cur_x = ob_p->trans->center.x;
move.c:		    point->x = arc_p->trans->center.x;
move.c:		    point->y = arc_p->trans->center.y;
move.c:			       arc_p->trans->orient);
move.c:	allign.trans->center.x = cur_x;
move.c:		point->y = arc_p->trans->center.y;
move.c:			   arc_p->trans->orient);
move.c:	cur_y = ob_p->trans->center.y;
move.c:		    point->x = arc_p->trans->center.x;
move.c:		    point->y = arc_p->trans->center.y;
move.c:			       arc_p->trans->orient);
move.c:	allign.trans->center.y = cur_y;
move.c:		point->x = arc_p->trans->center.x;
move.c:			   arc_p->trans->orient);
move.c:		       cur_arc->trans->orient);
move.c:    cur_trans->center.x = fix_x;
move.c:    cur_trans->center.y = fix_y;
move.c:    cur_trans->center.x = fix_x;
move.c:    cur_trans->center.y = fix_y;
move.c:		   cur_arc->trans->orient);
move.c:		cur_arc->point->x = cur_arc->trans->center.x;
move.c:		cur_arc->point->y = cur_arc->trans->center.y;
near.c:	 near_trans = near_trans->next)
near.c:	if (IsLayerListVisible(near_trans->layer))
near.c:	    if (x_loc < near_trans->center.x + trans_length &&
near.c:		y_loc < near_trans->center.y + trans_length &&
near.c:		x_loc > near_trans->center.x - trans_length &&
near.c:		y_loc > near_trans->center.y - trans_length)
near.c:	     near_trans = near_trans->next)
near.c:	    if (IsLayerListVisible(near_trans->layer))
near.c:		if (x_loc < near_trans->center.x + trans_length &&
near.c:		    y_loc < near_trans->center.y + trans_length &&
near.c:		    x_loc > near_trans->center.x - trans_length &&
near.c:		    y_loc > near_trans->center.y - trans_length)
near.c:	if (near.trans->kind == EXPONENTIAL)
near.c:	if (near.trans->kind == EXPONENTIAL)
net.c:	for (trans = netobj->trans; trans != NULL; trans = trans->next)
net.c:	    if (trans->rpar == rpar) {
net.c:		trans->rpar = NULL;
net.c:		trans->mark_dep = NULL;
net.c:	    for (trans = group->trans; trans != NULL; trans = trans->next)
net.c:		if (trans->rpar == rpar) {
net.c:		    trans->rpar = NULL;
net.c:		    trans->mark_dep = NULL;
net.c:    for (trans = selected.trans; trans != NULL; trans = trans->next)
net.c:	for (trans = group->trans; trans != NULL; trans = trans->next)
net.c:	trans_tmp = trans->next;
net.c:	if ((cp = trans->tag) != NULL)
net.c:	if ((cp = trans->color) != NULL)
net.c:	for (com = trans->mark_dep; com != NULL; com = com_tmp) {
net.c:	  if(trans->mark_dep != NULL)
net.c:	     free(trans->mark_dep);
net.c:	if (trans->enabl < 0)
net.c:	    free((char *) (trans->fire_rate.fp));
net.c:	free((char *) trans->layer);
net.c:	    trans_tmp = trans->next;
net.c:	    if ((cp = trans->tag) != NULL)
net.c:	    if ((cp = trans->color) != NULL)
net.c:	    for (com = trans->mark_dep; com != NULL; com = com_tmp) {
net.c:	 if(trans->mark_dep != NULL)
net.c:	    free(trans->mark_dep);
overview.c:    xc = trans->center.x / 5;
overview.c:    yc = trans->center.y / 5;
overview.c:    FNormTrans(trans, trans->center.x / 5, trans->center.y / 5, &xc, &yc);
overview.c:    if (trans->kind != EXPONENTIAL && trans->kind != DETERMINISTIC)
overview.c:		if (trans->kind == EXPONENTIAL)
overview.c:	 last_trans = last_trans->next)
overview.c:		if (IsLayerListVisible(last_trans->layer))
overview.c:	 last_trans = last_trans->next)
overview.c:		if (IsLayerListVisible(last_trans->layer))
parse.c:	 last_trans = last_trans->next)
parse.c:			if (strcmp(last_trans->tag, *Parsed) == 0 && last_trans != trans)
rate.c:      if (!IsLayerListVisible(trans->layer))
rate.c:   xloc = (trans->center.x + trans->ratepos.x) * zoom_level;
rate.c:   yloc = (trans->center.y + trans->ratepos.y) * zoom_level;
rate.c:   fprintf(stderr, "\nshow_trans_rate %s enabl=%d\n", trans->tag, trans->enabl);
rate.c:   if (trans->kind == DETERMINISTIC && trans->enabl == 1)
rate.c:   else if (trans->enabl != 1)
rate.c:      if (trans->enabl == 0)
rate.c:      else if (trans->enabl > 0)
rate.c:	 sprintf(rat, "%3d-server", trans->enabl);
rate.c:	 sprintf(rat, "%3d-en-dep", -(trans->enabl));
rate.c:   if (trans->mark_dep != NULL)
rate.c:   else if (trans->rpar != NULL)
rate.c:      sprintf(rat, "%s", (trans->rpar)->tag);
rate.c:   else if (trans->enabl >= 0)
rate.c:      sprintf(rat, "%f", trans->fire_rate.ff);
rate.c:      sprintf(rat, "%f", trans->fire_rate.fp[0]);
rate.c:	last_trans = last_trans->next)
rate.c:	   last_trans = last_trans->next)
rate.c:	if (near->trans->mark_dep != NULL)
rate.c:		if (near->trans->rpar != NULL)
rate.c:			sprintf(buffer, "transition %s rate : parameter %s", near->trans->tag, near->trans->rpar->tag);
rate.c:			if ((ii = near->trans->enabl) >= 0)
rate.c:				sprintf(buffer, "transition %s rate : %f", near->trans->tag, near->trans->fire_rate.ff);
rate.c:				sprintf(buffer, "transition %s rate : %f en_dep: 1.0",near->trans->tag, near->trans->fire_rate.fp[0]);
rate.c:					sprintf(rr, ", \n%f",	near->trans->fire_rate.fp[-(ii + (near->trans->enabl))]);
rate.c:    for (trans = netobj->trans; trans != NULL; trans = trans->next)
rate.c:	if (trans->rpar == near->rpars) {
rate.c:	    trans->rpar = NULL;
rate.c:	     trans = trans->next)
rate.c:	    if (trans->rpar == near->rpars) {
rate.c:		trans->rpar = NULL;
rate.c:   near->trans->ratepos.x = xloc - near->trans->center.x;
rate.c:   near->trans->ratepos.y = yloc - near->trans->center.y;
rate.c:   fix_x = (near->trans->center.x + near->trans->ratepos.x) * zoom_level;
rate.c:   fix_y = (near->trans->center.y + near->trans->ratepos.y) * zoom_level;
rate.c:   if (near->trans->kind == DETERMINISTIC && near->trans->enabl == 1)
rate.c:   else if (near->trans->enabl != 1)
rate.c:      if (near->trans->enabl == 0)
rate.c:      else if (near->trans->enabl < 0)
rate.c:	 sprintf(t_enabl_string, "%3d-en-dep", -(near->trans->enabl));
rate.c:	 sprintf(t_enabl_string, "%3d-server", near->trans->enabl);
rate.c:   if (near->trans->mark_dep != NULL)
rate.c:   else if (near->trans->rpar != NULL)
rate.c:      sprintf(t_rate_string, "%s", near->trans->rpar->tag);
rate.c:   else if (near->trans->enabl < 0)
rate.c:      sprintf(t_rate_string, "%f", near->trans->fire_rate.fp[0]);
rate.c:      sprintf(t_rate_string, "%f", near->trans->fire_rate.ff);
res.c:	for (trans = netobj->trans; trans != NULL; trans = trans->next)
res.c:		xloc = (trans->center.x + trans->ratepos.x) * zoom_level;
res.c:		yloc = (trans->center.y + trans->ratepos.y + 10) * zoom_level;
res.c:		if ( trans->through2 > 0.0 )
res.c:			sprintf(linebuf, "Thru=%g+/-%g", trans->through1, trans->through2);
res.c:			sprintf(linebuf, "Thru=%g", trans->through1);
res.c:		trans->through1 = 0.0;
res.c:		for (trans = group->trans; trans != NULL; trans = trans->next) {
res.c:			xloc = (trans->center.x + trans->ratepos.x) * zoom_level;
res.c:			yloc = (trans->center.y + trans->ratepos.y + 10) * zoom_level;
res.c:			if ( trans->through2 > 0.0 )
res.c:				sprintf(linebuf, "Thru=%g+/-%g", trans->through1, trans->through2);
res.c:				sprintf(linebuf, "Thru=%g", trans->through1);
res.c:			trans->through1 = 0.0;
res.c:	for (trans = netobj->trans; trans != NULL; trans = trans->next) {
res.c:	xloc = (trans->center.x + trans->ratepos.x) * zoom_level;
res.c:	yloc = (trans->center.y + trans->ratepos.y + 10) * zoom_level;
res.c:	if ( trans->through2 > 0.0 )
res.c:		sprintf(linebuf, "Thru=%g+/-%g", trans->through1, trans->through2);
res.c:		sprintf(linebuf, "Thru=%g", trans->through1);
res.c:	for (trans = group->trans; trans != NULL; trans = trans->next) {
res.c:		xloc = (trans->center.x + trans->ratepos.x) * zoom_level;
res.c:		yloc = (trans->center.y + trans->ratepos.y + 10) * zoom_level;
res.c:		if ( trans->through2 > 0.0 )
res.c:		sprintf(linebuf, "Thru=%g+/-%g", trans->through1, trans->through2);
res.c:		sprintf(linebuf, "Thru=%g", trans->through1);
res.c:	for (trans = netobj->trans; trans != NULL; trans = trans->next) 
res.c:		if ( sscanf(c_p, "%g +/- %g", &(trans->through1), &(trans->through2)) < 2 )
res.c:			trans->through2 = -1.0;
res.c:		xloc = (trans->center.x + trans->ratepos.x) * zoom_level;
res.c:		yloc = (trans->center.y + trans->ratepos.y + 10) * zoom_level;
res.c:		if ( trans->through2 > 0.0 )
res.c:			sprintf(linebuf, "Thru=%g+/-%g", trans->through1, trans->through2);
res.c:			sprintf(linebuf, "Thru=%g", trans->through1);
res.c:		for (trans = group->trans; trans != NULL; trans = trans->next) 
res.c:			if ( sscanf(c_p, "%g +/- %g", &(trans->through1), &(trans->through2)) < 2 )
res.c:				trans->through2 = -1.0;
res.c:			xloc = (trans->center.x + trans->ratepos.x) * zoom_level;
res.c:			yloc = (trans->center.y + trans->ratepos.y + 10) * zoom_level;
res.c:			if ( trans->through2 > 0.0 )
res.c:				sprintf(linebuf, "Thru=%g+/-%g", trans->through1, trans->through2);
res.c:				sprintf(linebuf, "Thru=%g", trans->through1);
rescale.c:    for (trans = net->trans; trans != NULL; trans = trans->next) {
rescale.c:	trans->center.x = rescale_x(trans->center.x);
rescale.c:	trans->center.y = rescale_y(trans->center.y);
rescale.c:	trans->tagpos.x *= how_much;
rescale.c:	trans->tagpos.y *= how_much;
rescale.c:	trans->pripos.x *= how_much;
rescale.c:	trans->pripos.y *= how_much;
rescale.c:	trans->colpos.x *= how_much;
rescale.c:	trans->colpos.y *= how_much;
rescale.c:	trans->ratepos.x *= how_much;
rescale.c:	trans->ratepos.y *= how_much;
rescale.c:	for (trans = group->trans; trans != NULL; trans = trans->next) {
rescale.c:	    trans->center.x = rescale_x(trans->center.x);
rescale.c:	    trans->center.y = rescale_y(trans->center.y);
rescale.c:	    trans->tagpos.x *= how_much;
rescale.c:	    trans->tagpos.y *= how_much;
rescale.c:	    trans->pripos.x *= how_much;
rescale.c:	    trans->pripos.y *= how_much;
rescale.c:	    trans->colpos.x *= how_much;
rescale.c:	    trans->colpos.y *= how_much;
rescale.c:	    trans->ratepos.x *= how_much;
rescale.c:	    trans->ratepos.y *= how_much;
rescale.c:	    arc->point->x = arc->trans->center.x;
rescale.c:	    arc->point->y = arc->trans->center.y;
rescale.c:		       arc->trans->orient);
restore.c:				 trans->next != NULL;
restore.c:				 trans = trans->next);
restore.c:			    trans->next = auxgr->trans;
restore.c:			 trans->next != NULL;
restore.c:			 trans = trans->next);
restore.c:		    trans->next = g_p->movelink->trans;
save.c:	 trans = trans->next, notr++);
save.c:	     trans = trans->next, notr++);
save.c:    for (trans = netobj->trans, notr = 0; trans != NULL; trans = trans->next)
save.c:	put_trans(netobj, trans, trans->kind, ++notr);
save.c:	for (trans = group->trans; trans != NULL; trans = trans->next)
save.c:    putname(nfp, trans->tag);
save.c:    endep = trans->enabl;
save.c:    if (trans->mark_dep != NULL) {
save.c:	for (comm = trans->mark_dep; comm != NULL; comm = comm->next)
save.c:	 fprintf(dfp, "%s\n", trans->mark_dep);
save.c:	 printf( "Save Mark Dep %s\n", trans->mark_dep);
save.c:    else if (trans->rpar == NULL) {
save.c:	    ftemp = trans->fire_rate.fp[0];
save.c:	    ftemp = trans->fire_rate.ff;
save.c:	     rpar != trans->rpar; rpar = rpar->next, i--);
save.c:	    ftemp, trans->enabl, knd, j, trans->orient,
save.c:	    PIX_TO_IN(trans->center.x), PIX_TO_IN(trans->center.y),
save.c:	    PIX_TO_IN(trans->tagpos.x + trans->center.x),
save.c:	    PIX_TO_IN(trans->tagpos.y + trans->center.y),
save.c:	    PIX_TO_IN(trans->ratepos.x + trans->center.x),
save.c:	    PIX_TO_IN(trans->ratepos.y + trans->center.y));
save.c:    print_layer(trans->layer);
save.c:    if (trans->lisp != NULL) {
save.c:	for (; lisp != trans->lisp; lisp = lisp->next)
save.c:		PIX_TO_IN(trans->colpos.x + trans->center.x),
save.c:		PIX_TO_IN(trans->colpos.y + trans->center.y),
save.c:    else if (trans->color != NULL)
save.c:		PIX_TO_IN(trans->colpos.x + trans->center.x),
save.c:		PIX_TO_IN(trans->colpos.y + trans->center.y),
save.c:		trans->color);
save.c:	    fprintf(nfp, " %f\n", trans->fire_rate.fp[(endep - i)]);
sc.c:    c_p->x = trans->center.x;
sc.c:    c_p->y = trans->center.y;
sc.c:    sprintf(string, "transition %s is not contained in any structural conflit ", cur_trans->tag);
search2.c:	for (trans = netobj->trans; trans != NULL; trans = trans->next)
search2.c:		if (IsLayerListVisible(trans->layer)) {
search2.c:			if (trans->mark_dep == NULL && (
search2.c:							trans->rpar == NULL && (
search2.c:			 trans->enabl >= 0 && trans->fire_rate.ff == s_float
search2.c:			   trans->enabl < 0 && trans->fire_rate.fp[0] == s_float
search2.c:			trans->rpar != NULL && trans->rpar->value == s_float
search2.c:			highlight_search(trans->center);
search2.c:			if (trans->mark_dep == NULL && trans->rpar != NULL &&
search2.c:			strcmp(trans->rpar->tag, s_string) == 0) {
search2.c:			highlight_search(trans->center);
search2.c:		for (trans = group->trans; trans != NULL; trans = trans->next)
search2.c:		if (IsLayerListVisible(trans->layer)) {
search2.c:			if (trans->mark_dep == NULL &&
search2.c:				( trans->rpar == NULL &&
search2.c:				  trans->fire_rate.ff == s_float ||
search2.c:				  trans->rpar != NULL &&
search2.c:				  trans->rpar->value == s_float
search2.c:			    highlight_search(trans->center);
search2.c:			if (trans->mark_dep == NULL && trans->rpar != NULL &&
search2.c:			    strcmp(trans->rpar->tag, s_string) == 0) {
search2.c:			    highlight_search(trans->center);
search2.c:	for (trans = netobj->trans; trans != NULL; trans = trans->next)
search2.c:	    if (IsLayerListVisible(trans->layer))
search2.c:		if (strcmp(trans->tag, s_string) == 0) {
search2.c:		    highlight_search(trans->center);
search2.c:	    for (trans = group->trans; trans != NULL; trans = trans->next)
search2.c:		if (IsLayerListVisible(trans->layer))
search2.c:		    if (strcmp(trans->tag, s_string) == 0) {
search2.c:			highlight_search(trans->center);
search2.c:	for (trans = netobj->trans; trans != NULL; trans = trans->next)
search2.c:	    if (IsLayerListVisible(trans->layer) {
search2.c:		if (trans->color != NULL
search2.c:			&& strcmp(trans->color, s_string) == 0
search2.c:		    || trans->lisp != NULL
search2.c:		    && strcmp(trans->lisp->tag, s_string) == 0) {
search2.c:		    highlight_search(trans->center);
search2.c:	    for (trans = group->trans; trans != NULL; trans = trans->next)
search2.c:		if (IsLayerListVisible(trans->layer)) {
search2.c:		    if (trans->color != NULL
search2.c:			&& strcmp(trans->color, s_string) == 0
search2.c:			|| trans->lisp != NULL
search2.c:			&& strcmp(trans->lisp->tag, s_string) == 0) {
search2.c:			highlight_search(trans->center);
search2.c:	for (trans = netobj->trans; trans != NULL; trans = trans->next)
search2.c:	    if (IsLayerListVisible(trans->layer))
search2.c:		if (strcmp(trans->tag, s_string) == 0) {
search2.c:		    highlight_search(trans->center);
search2.c:	    for (trans = group->trans; trans != NULL; trans = trans->next)
search2.c:		if (IsLayerListVisible(trans->layer))
search2.c:		    if (strcmp(trans->tag, s_string) == 0) {
search2.c:			highlight_search(trans->center);
select.c:	       if (!IsLayerListVisible(arc->trans->layer)
select.c:		   || !is_in_move(arc->trans->center))
select.c:		  arc->point->x = -arc->trans->center.x;
select.c:		  arc->point->y = -arc->trans->center.y;
select.c:      if (IsLayerListVisible(trans->layer)
select.c:	  && is_in_move(trans->center))
select.c:	    netobj->trans = trans->next;
select.c:	    temp_tr->next = trans->next;
select.c:	 trans->next = selected.trans;
select.c:	       arc->point->x = trans->center.x;
select.c:	       arc->point->y = trans->center.y;
select.c:	 trans = trans->next;
select.c:	 if (IsLayerListVisible(trans->layer)
select.c:	     && is_in_move(trans->center))
select.c:	       group->trans = trans->next;
select.c:	       temp_tr->next = trans->next;
select.c:	    trans->next = mv_group->trans;
select.c:		  arc->point->x = trans->center.x;
select.c:		  arc->point->y = trans->center.y;
select.c:	    trans = trans->next;
select.c:	    arc->point->x = arc->trans->center.x;
select.c:	    arc->point->y = arc->trans->center.y;
select.c:		       arc->trans->orient);
select.c:	    arc->point->x = -arc->trans->center.x;
select.c:	    arc->point->y = -arc->trans->center.y;
select.c:      near->trans->next = group->trans;
select.c:	 near->trans->next = selected.trans;
select.c:	    arc->point->x = arc->trans->center.x;
select.c:	    arc->point->y = arc->trans->center.y;
select.c:		       arc->trans->orient);
select.c:	    arc->point->x = arc->trans->center.x;
select.c:	    arc->point->y = arc->trans->center.y;
select.c:   for (trans = selected.trans; trans != NULL; trans = trans->next)
select.c:      newx = trans->center.x;
select.c:      newy = trans->center.y;
select.c:      for (trans = group->trans; trans != NULL; trans = trans->next)
select.c:	 newx = trans->center.x;
select.c:	 newy = trans->center.y;
select.merge.c:	       if (!IsLayerListVisible(arc->trans->layer)
select.merge.c:		   || !is_in_move(arc->trans->center))
select.merge.c:		  arc->point->x = -arc->trans->center.x;
select.merge.c:		  arc->point->y = -arc->trans->center.y;
select.merge.c:      if (IsLayerListVisible(trans->layer)
select.merge.c:	  && is_in_move(trans->center))
select.merge.c:	    sel_netobj->trans = trans->next;
select.merge.c:	    temp_tr->next = trans->next;
select.merge.c:	 trans->next = selected.trans;
select.merge.c:	       arc->point->x = trans->center.x;
select.merge.c:	       arc->point->y = trans->center.y;
select.merge.c:	 trans = trans->next;
select.merge.c:	 if (IsLayerListVisible(trans->layer)
select.merge.c:	     && is_in_move(trans->center))
select.merge.c:	       group->trans = trans->next;
select.merge.c:	       temp_tr->next = trans->next;
select.merge.c:	    trans->next = mv_group->trans;
select.merge.c:		  arc->point->x = trans->center.x;
select.merge.c:		  arc->point->y = trans->center.y;
select.merge.c:	    trans = trans->next;
select.merge.c:	    arc->point->x = arc->trans->center.x;
select.merge.c:	    arc->point->y = arc->trans->center.y;
select.merge.c:		       arc->trans->orient);
select.merge.c:	    arc->point->x = -arc->trans->center.x;
select.merge.c:	    arc->point->y = -arc->trans->center.y;
select.merge.c:      near->trans->next = group->trans;
select.merge.c:	 near->trans->next = selected.trans;
select.merge.c:	    arc->point->x = arc->trans->center.x;
select.merge.c:	    arc->point->y = arc->trans->center.y;
select.merge.c:		       arc->trans->orient);
select.merge.c:	    arc->point->x = arc->trans->center.x;
select.merge.c:	    arc->point->y = arc->trans->center.y;
select.merge.c:   for (trans = selected.trans; trans != NULL; trans = trans->next)
select.merge.c:      newx = trans->center.x;
select.merge.c:      newy = trans->center.y;
select.merge.c:      for (trans = group->trans; trans != NULL; trans = trans->next)
select.merge.c:	 newx = trans->center.x;
select.merge.c:	 newy = trans->center.y;
showgdi.c:	switch(trans->kind)
showgdi.c:			ToDrawPix=extranspix[trans->orient];
showgdi.c:			ToDrawPix=detranspix[trans->orient];
showgdi.c:			ToDrawPix=imtranspix[trans->orient];
spline.c:	xctrans = arc->trans->center.x;
spline.c:	yctrans = arc->trans->center.y;
spline.c:			sprintf(string, "%s", arc->trans->tag);
spline.c:			sprintf(string, "%1d*%s", -(arc->mult), arc->trans->tag);
spline.c:	xctrans = ABS(arc->trans->center.x);
spline.c:	yctrans = ABS(arc->trans->center.y);
tag.c:	for (last_trans = netobj->trans; last_trans != NULL; last_trans = last_trans->next)
tag.c:		if (IsLayerListVisible(last_trans->layer))
tag.c:		for (last_trans = group->trans; last_trans != NULL; last_trans = last_trans->next)
tag.c:			if (IsLayerListVisible(last_trans->layer))
tag.c:	xloc = (trans->center.x + trans->tagpos.x - x_off) * zoom_level;
tag.c:	yloc = (trans->center.y + trans->tagpos.y - y_off) * zoom_level;
tag.c:	gdiDrawText(ds, (int) (xloc), (int) (yloc), op, canvas_font, trans->tag);
tag.c:	      XOR, canvas_font, near->trans->tag);
tag.c:      if (near->trans->kind > 1)
tag.c:	 ShowTransPri(fix_x, fix_y, (int) near->trans->kind, &mainDS,XOR);
tag.c:			(int) near->trans->kind, &mainDS,XOR);
tag.c:      gdiDrawText(&mainDS, x, y, XOR, canvas_font, near->trans->tag);
tag.c:	      XOR, canvas_font, near->trans->tag);
tag.c:      gdiDrawText(&mainDS, x, y, XOR, canvas_font, near->trans->tag);
tag.c:	      XOR, canvas_font, near->trans->tag);
tag.c:      near->trans->tagpos.x = xloc - near->trans->center.x;
tag.c:      near->trans->tagpos.y = yloc - near->trans->center.y;
tag.c:	      XOR, canvas_font, near->trans->tag);
tag.c:      if (near->trans->kind > 1)
tag.c:	 ShowTransPri((float) near->trans->tagpos.x,
tag.c:			(float) near->trans->tagpos.y,
tag.c:			(int) near->trans->kind, &mainDS,XOR);
tag.c:	      XOR, canvas_font, near->trans->tag);
tag.c:      near->trans->tagpos.x = xloc - near->trans->center.x;
tag.c:      near->trans->tagpos.y = yloc - near->trans->center.y;
tag.c:	      XOR, canvas_font, near->trans->tag);
tag.c:      fix_x = (near->trans->center.x + near->trans->tagpos.x) * zoom_level;
tag.c:      fix_y = (near->trans->center.y + near->trans->tagpos.y) * zoom_level;
tinv.c:    c_p->x = trans->center.x;
tinv.c:    c_p->y = trans->center.y;
tinv.c:    sprintf(string, "transition %s is not contained in any T-invariant", cur_trans->tag);
tokens.c:    for (length = 0.0, px = cur_trans->center.x, py = cur_trans->center.y,
tokens.c:	 px = cur_trans->center.x, py = cur_trans->center.y,
tramd.c:    sprintf(string, "transition %s m-d rate : \n%s", trans->tag,trans->mark_dep);	
trans.c:	cur_trans->tag = (char *) emalloc(TAG_SIZE);
trans.c:	loop: sprintf(cur_trans->tag, "t%d", ++trans_num);
trans.c:	 last_trans = last_trans->next)
trans.c:		if (strcmp(last_trans->tag, cur_trans->tag) == 0)
trans.c:	 last_trans = last_trans->next)
trans.c:			if (strcmp(last_trans->tag, cur_trans->tag) == 0) 
trans.c:	cur_trans->center.x = fix_x;
trans.c:	cur_trans->center.y = fix_y;
trans.c:	cur_trans->orient = cur_orient;
trans.c:	cur_trans->enabl = 1;
trans.c:	cur_trans->enabled = FALSE;
trans.c:	cur_trans->kind = IMMEDIATE;
trans.c:	cur_trans->fire_rate.ff = 1.0;
trans.c:	cur_trans->rpar = NULL;
trans.c:	cur_trans->mark_dep = NULL;
trans.c:	cur_trans->tagpos.x = -(trans_length / 2 + 10);
trans.c:	cur_trans->tagpos.y = -18;
trans.c:	cur_trans->color = NULL;
trans.c:	cur_trans->lisp = NULL;
trans.c:	cur_trans->colpos.x = trans_length / 2 + 3;
trans.c:	cur_trans->colpos.y = -7;
trans.c:	cur_trans->ratepos.x = trans_length / 2 + 3;
trans.c:	cur_trans->ratepos.y = titrans_height / 2 + 2;
trans.c:	cur_trans->layer = NewLayerList(CURRENTVIEWANDWHOLE,NULL);
trans.c:		cur_trans->next = NULL;
trans.c:		cur_trans->next = group->trans;
trans.c:	cur_trans->tag = (char *) emalloc(TAG_SIZE);
trans.c:	loop: sprintf(cur_trans->tag, "T%d", ++trans_num);
trans.c:	 last_trans = last_trans->next)
trans.c:		if (strcmp(last_trans->tag, cur_trans->tag) == 0) 
trans.c:	 last_trans = last_trans->next)
trans.c:			if (strcmp(last_trans->tag, cur_trans->tag) == 0) 
trans.c:		for (last_trans = netobj->trans; last_trans->next != NULL;
trans.c:		 last_trans = last_trans->next);
trans.c:		last_trans->next = cur_trans;
trans.c:	cur_trans->next = NULL;
trans.c:	cur_trans->center.x = fix_x;
trans.c:	cur_trans->center.y = fix_y;
trans.c:	cur_trans->orient = cur_orient;
trans.c:    cur_trans->enabl = 0;
trans.c:    cur_trans->enabled = FALSE;
trans.c:		cur_trans->kind = DETERMINISTIC;
trans.c:		cur_trans->kind = EXPONENTIAL;
trans.c:    cur_trans->fire_rate.ff = 1.0;
trans.c:    cur_trans->rpar = NULL;
trans.c:    cur_trans->mark_dep = NULL;
trans.c:    cur_trans->tagpos.x = -(trans_length / 2 + 3);
trans.c:    cur_trans->tagpos.y = -7;
trans.c:    cur_trans->color = NULL;
trans.c:    cur_trans->lisp = NULL;
trans.c:    cur_trans->colpos.x = trans_length / 2 + 3;
trans.c:    cur_trans->colpos.y = -7;
trans.c:    cur_trans->ratepos.x = trans_length / 2 + 3;
trans.c:    cur_trans->ratepos.y = titrans_height / 2 + 2;
trans.c:    cur_trans->layer = NewLayerList(CURRENTVIEWANDWHOLE,NULL);
trans.c:    cur_trans->orient = rot_trans((int) (cur_trans->orient), ROTATE45);
trans.c:			t_p->x = cur_trans->center.x;
trans.c:			t_p->y = cur_trans->center.y;
trans.c:			ChopTrans(&(t_p->x), &(t_p->y), n_p->x, n_p->y, cur_trans->orient);
trans.c:      ResetVisibleLayers(near->trans->layer);
trans.c:		 trans = trans->next)
trans.c:	    && group->trans->next == NULL)
trans.c:    near->trans->next = NULL;
trans.c:    if (trans->kind == EXPONENTIAL || trans->kind == DETERMINISTIC) 
trans.c:			netobj->trans = trans->next;
trans.c:		for (last_trans = netobj->trans; last_trans->next != NULL;
trans.c:	     last_trans = last_trans->next)
trans.c:			if (last_trans->next == trans) 
trans.c:				last_trans->next = trans->next;
trans.c:				group->trans = trans->next;
trans.c:			for (last_trans = group->trans; last_trans->next != NULL;
trans.c:			 last_trans = last_trans->next)
trans.c:				if (last_trans->next == trans) 
trans.c:					last_trans->next = trans->next;
transdialog.c:    dialog_trans->kind = ppp;
transdialog.c:		dialog_trans->next = NULL;
transdialog.c:		dialog_trans->next = NULL;
transdialog.c:		dialog_trans->next = group->trans;
transdialog.c:	dialog_trans->next = NULL;
transdialog.c:	process_focus = dialog_trans->enabl < 0;
transdialog.c:	has_ratepar = dialog_trans->rpar;
transdialog.c:	if (dialog_trans->tag != NULL)
transdialog.c:		XmTextFieldSetString(trans_tag, dialog_trans->tag);
transdialog.c:	if (dialog_trans->color != NULL)
transdialog.c:		XmTextFieldSetString(trans_color, dialog_trans->color);
transdialog.c:			if (dialog_trans->mark_dep != NULL)
transdialog.c:				strcpy(trans_markdep_str, dialog_trans->mark_dep);
transdialog.c:				XmToggleButtonGadgetSetState(trans_infinite, dialog_trans->enabl == 0, TRUE);
transdialog.c:				XmToggleButtonGadgetSetState(trans_nserv, dialog_trans->enabl > 0, TRUE);
transdialog.c:				XmToggleButtonGadgetSetState(trans_loaddep, dialog_trans->enabl < 0, TRUE);
transdialog.c:				UpdateTransChangeDialogLabel(dialog_trans->enabl >= 0 ? LABEL_RATE : LABEL_EMPTY);
transdialog.c:				if (dialog_trans->enabl == 0)
transdialog.c:					if (dialog_trans->rpar == NULL)
transdialog.c:						sprintf(trans_ratepar_str, "%f", dialog_trans->fire_rate.ff);
transdialog.c:						strcpy(trans_ratepar_str, dialog_trans->rpar->tag);
transdialog.c:					if (dialog_trans->enabl > 0)
transdialog.c:						if (dialog_trans->rpar == NULL)
transdialog.c:							sprintf(trans_ratepar_str, "%f", dialog_trans->fire_rate.ff);
transdialog.c:							strcpy(trans_ratepar_str, dialog_trans->rpar->tag);
transdialog.c:						XmScaleSetValue(trans_scale, dialog_trans->enabl);
transdialog.c:						old_scale = dialog_trans->enabl;
transdialog.c:						XmScaleSetValue(trans_scale, -dialog_trans->enabl);
transdialog.c:						for (i = 0; i < (-dialog_trans->enabl); i++)
transdialog.c:								sprintf(temp, "%4d --> %f", i + 1, dialog_trans->fire_rate.fp[i]);
transdialog.c:								if (dialog_trans->rpar == NULL)
transdialog.c:									sprintf(temp, "Rate --> %f", dialog_trans->fire_rate.fp[i]);
transdialog.c:									sprintf(temp, "Rate Par --> %s", dialog_trans->rpar->tag);
transdialog.c:							trans_values[i] = dialog_trans->fire_rate.fp[i];
transdialog.c:						XmListAddItems(trans_list, strings, -dialog_trans->enabl, 0);
transdialog.c:						for (i = 0; i < -dialog_trans->enabl; i++)
transdialog.c:						old_scale = -dialog_trans->enabl;
transdialog.c:				XmScaleSetValue(trans_pri,dialog_trans->kind == DETERMINISTIC ? 1 : dialog_trans->kind);
transdialog.c:			if (dialog_trans->rpar == NULL)
transdialog.c:				sprintf(trans_ratepar_str, "%f", dialog_trans->fire_rate.ff);
transdialog.c:				strcpy(trans_ratepar_str, dialog_trans->rpar->tag);
transdialog.c:	XtSetArg(args[0], XmNset, trans->kind == EXPONENTIAL);
transdialog.c:	XtSetArg(args[0], XmNset, trans->kind != EXPONENTIAL && trans->kind != DETERMINISTIC);
transdialog.c:	XtSetArg(args[0], XmNset, trans->kind == DETERMINISTIC);
transdialog.c:	trans_kind = trans->kind;
transdialog.c:	if(trans->kind ==  EXPONENTIAL)
transdialog.c:	if (dialog_trans->mark_dep != NULL)
transdialog.c:		free(dialog_trans->mark_dep);
transdialog.c:	if (dialog_trans->tag != NULL)
transdialog.c:		free(dialog_trans->tag);
transdialog.c:	dialog_trans->tag = tag;
transdialog.c:	dialog_trans->mark_dep = NULL;
transdialog.c:	dialog_trans->rpar = NULL;
transdialog.c:	if (dialog_trans->enabl < 0)
transdialog.c:		free(dialog_trans->fire_rate.fp);
transdialog.c:	if (dialog_trans->color != NULL)
transdialog.c:		free(dialog_trans->color);
transdialog.c:		dialog_trans->colpos.x = trans_length / 2 + 3;
transdialog.c:		dialog_trans->colpos.y = -7;
transdialog.c:	dialog_trans->color = NULL;
transdialog.c:	dialog_trans->lisp = NULL;
transdialog.c:		dialog_trans->color = emalloc(strlen(color) + 1);
transdialog.c:		strcpy(dialog_trans->color, color);
transdialog.c:	if (dialog_trans->kind != EXPONENTIAL && dialog_trans->kind != DETERMINISTIC)
transdialog.c:			dialog_trans->kind = EXPONENTIAL;
transdialog.c:			dialog_trans->next = netobj->trans;
transdialog.c:			dialog_trans->enabl = enabling;
transdialog.c:				dialog_trans->mark_dep = strdup(text);
transdialog.c:					dialog_trans->fire_rate.fp = (float *) emalloc(-enabling * sizeof(float));
transdialog.c:					memcpy(dialog_trans->fire_rate.fp, trans_values, -enabling * sizeof(float));
transdialog.c:					dialog_trans->rpar = has_ratepar;
transdialog.c:					dialog_trans->fire_rate.ff = rate;
transdialog.c:					dialog_trans->rpar = rp;
transdialog.c:			sprintf(linebuf, "transition %s is now exponential (inf-server)", dialog_trans->tag);
transdialog.c:			dialog_trans->kind = DETERMINISTIC;
transdialog.c:			dialog_trans->next = netobj->trans;
transdialog.c:			dialog_trans->fire_rate.ff = rate;
transdialog.c:			dialog_trans->rpar = rp;
transdialog.c:			dialog_trans->enabl = 0;
transdialog.c:			sprintf(linebuf, "transition %s is now deterministic", dialog_trans->tag);
transdialog.c:			dialog_trans->enabl = 1;
transdialog.c:			dialog_trans->fire_rate.ff = rate;
transdialog.c:			dialog_trans->rpar = rp;
transdialog.c:			sprintf(linebuf, "transition %s is now immediate", dialog_trans->tag);
unbound.c:		HighlightUnbound(tip->trans->center);
unbound.c:		strcat(string, tip->trans->tag);
